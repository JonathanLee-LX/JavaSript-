# this 对象全面解析

## 调用位置

在理解 this 的绑定过程之前，首先需要了解*调用位置*：
调用位置就是函数在代码中被调用的位置（而不是声明的位置）。只有仔细分析调用位置才能回答这个问题：这个`this`到底引用了什么？
通常来说，寻找调用位置就是寻找“函数被调用时的位置”，但是做起来并没有这么简单，因为有些**编程模式**会隐藏函数真正调用的位置。
最重要的是要分析调用栈（就是为了到达当前执行位置所调用的所有函数）。我们关心的调用位置就是当前正在执行的函数的前一个调用中。
下面我们来看看到底什么是调用栈和调用位置：

```js
function baz() {
  console.log('baz');
  bar();
}

function bar() {
  console.log('bar');
  foo();
}

function foo() {
  console.log('foo');
}

baz();
```

注意我们是如何（从调用栈中）分析真正的调用位置的，因为它决定了`this`的绑定。

## 绑定规则

我们来看看在函数的执行过程中调用位置如何决定`this`的绑定对象。
你必须找到调用位置，然后判断需要应用下面这四条规则中的哪一条。我们首先会分别解释这四条规则，然后解释多条规则都可用是它们的优先级如何排序。

### 默认绑定

首先要介绍的是最常用的函数调用类型：独立函数调用。可以把这条规则看作是无法应用其他规则时的默认规则。
思考一下下面的代码：

```js
function foo() {
  console.log(this.a);
}
var a = 2;
foo(); // 2
```

你应该注意到的第一件事，声明在全局作用域中的变量（比如 var a = 2）就是全局对象的一个属性。它们本质就是同一个东西，并不是通过复制得到的，就像一个硬币的两面一样。
接下来，我们看到当调用 foo()时，this.a 被解析成了全局变量 a。为什么？因为在本例中，函数调用时应用了 this 的默认绑定，因此 this 指向全局对象。
那么我们怎么知道这里应用了默认绑定呢？可以通过分析调用位置来看看 foo()是如何调用的。在代码中，foo()是直接使用了不带任何修饰的函数的引用进行调用的，因此只能使用默认绑定，无法应用其他规则。
如果使用严格模式（strict mode),则不能将全局对象用于默认绑定，因此 this 会绑定到 undefined：

```js
function foo() {
  'use strict';
  console.log(this.a);
}
var a = 2;
foo(); // TypeError: Cannot read property 'a' of undefined
```

> 通常来说你不应该在代码中混合使用 strict 模式和非 strict 模式。整改程序要么严格要么非严格。然而，有时候你可能会用到第三方库，其严格程度和你的代码有所不同，因此一定要注意这类兼容性的细节。

### 隐形绑定

另一条需要考虑的规则是调用位置是否有上下文对象，或则说是否被某个对象拥有或者包含，不过这种说法可能会造成一些误导。
思考下面这些代码：

```js
function foo() {
  console.log(this.a);
}

var obj = {
  a: 2,
  foo: foo,
};

obj.foo(); // 2
```

首先需要注意的是 foo()的声明方式，及其之后是如何被当作引用属性添加到 obj 中的，但是无论是直接在 obj 中定义还是先定义再添加为引用属性，这个函数严格来说都不属于 obj 对象。
然而，调用位置会使用 obj 上下文来引用函数，因此你可以说函数被调用时 obj 对象“拥有”或者“包含”它。
无论你如何称呼这个模式，当 foo()被调用时，它前面确实加上了对 obj 的引用。**当函数引用有上下文对象时**，*隐式绑定*规则会把函数调用中的 this 绑定到这个上下文对象。因为调用 foo()时 this 被绑定到 obj，因此`this.a`和`obj.a`时一样的。
对象属性引用链中只有上一层或者说是最后一层再调用位置中起作用。举例来说：

```js
function foo() {
  console.log(this.a);
}

var a = 0;

var obj1 = {
  a: 1,
  foo: foo,
};

var obj2 = {
  a: 2,
  obj1: obj1,
};
obj1.foo(); // 1
obj2.obj1.foo(); // 1
```

#### 隐式丢失

一个最常见的问题就是被隐式绑定的函数会丢失绑定对象，也就是说会应用**默认绑定**，从而把 this 绑定到全局对象或则 undefined 上，取决于是否是严格模式。
思考下面的代码：

```js
function foo() {
  console.log(this.a);
}

var a = 0;
var obj = {
  a: 1,
  foo: foo,
};
var bar = obj.foo;
bar(); // 0
```

虽然 bar 是 obj.foo 的一个引用，但是实际上，它引用的是 foo 函数本身，因此此时的 bar()其实是一个不带任何修饰的函数调用，因此应用了默认绑定。
一种更微妙，更常见并且出乎意料的情况发生再传入回调函数时：

```js
function foo() {
  console.log(this.a);
}
function doFoo(fn) {
  fn();
}

var obj = {
  a: 1,
  foo: foo,
};

var a = 0;

doFoo(obj.foo); // 0
```

参数传递其实就是一种隐式赋值，因此我们传入函数时也会被隐式赋值，所以结果和上一个例子一样。
如果把函数传入 JavaScript 内置的函数会怎么样呢？答案是一样的，没有任何区别：

```js
function foo() {
  console.log(this.a);
}

var obj = {
  a: 1,
  foo: foo,
};

var a = 'oops, global';

setTimeout(obj.foo, 1000); // "oops, global"
```
